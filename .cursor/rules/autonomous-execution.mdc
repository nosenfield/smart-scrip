---
description: Autonomous execution mode for zero-to-one development
alwaysApply: false
---

# Autonomous Execution Mode

## Purpose

This file defines rules for autonomous batch execution of development tasks, enabling the agent to complete entire phases without user intervention between tasks. This mode is activated by commands like `/one-shot` and `/batch`.

---

## Execution Modes

### Manual Mode (Default)
- Agent waits for approval after each task
- User reviews plans before implementation
- Explicit commit approval required
- Activated by: `/plan`, `/implement`, individual task commands

### Autonomous Mode
- Agent executes multiple tasks sequentially
- Plans are created silently (not shown to user)
- Commits proceed through approval workflow automatically
- Only stops for errors, failures, or phase completion
- Activated by: `/one-shot Phase N`, `/batch [tasks]`

---

## Autonomous Mode Behavior

### Core Principle
**In autonomous mode, the agent operates continuously without user intervention EXCEPT for errors, failures, or explicit ambiguities.**

### When to Pause in Autonomous Mode

**MUST PAUSE for:**
- Test failures after 3 retry attempts
- Task requirements are ambiguous or unclear
- Pre-commit hook failures (non-review errors like linting, type errors)
- Critical errors that cannot be auto-resolved
- Phase completion (for summary and review)

**DO NOT PAUSE for:**
- Task completion (continue to next task immediately)
- Successful commits (continue to next task immediately)
- Memory bank updates (do automatically)
- Task tracker updates (do automatically)
- Claude code review iterations (handle automatically via approval workflow)

### Task Execution Flow in Autonomous Mode

```
For each task in queue:
  1. Read context (memory-bank, task details, rules)
  2. Plan implementation (SILENTLY - do not show to user)
  3. Write tests first (TDD)
  4. Implement to pass tests
  5. Run tests (retry up to 3 times if failures)
  6. Update documentation (memory bank, task tracker)
  7. Commit via approval workflow (see below)
  8. IMMEDIATELY continue to next task (DO NOT PAUSE)

After all tasks complete:
  9. Update memory bank (if phase complete or 90% context)
  10. Update task tracker
  11. Generate phase summary (if phase complete)
  12. Report completion and pause
```

---

## Commit Approval Workflow

### Overview

All commits go through the pre-commit hook which triggers Claude code review. The hook is interactive and will always block the first commit attempt, returning control to the Cursor agent for review and iteration.

### The Approval Cycle

```
┌─────────────────────────────────────────────────────────┐
│ Agent: git commit -m "message"                          │
│ ↓                                                        │
│ Pre-commit Hook: Triggers Claude review (INTERACTIVE)   │
│ ↓                                                        │
│ Claude: Reviews code, provides feedback                 │
│ ↓                                                        │
│ Hook: Prompts user (y/n/v) - BLOCKS execution          │
│ ↓                                                        │
│ Returns to Agent with review feedback                   │
│ ↓                                                        │
│ Agent: Analyzes Claude's review                         │
│ ↓                                                        │
│ IF: Approval + no changes needed                        │
│   → Agent: git commit -m "same message"                 │
│         with AUTO_ACCEPT=true                           │
│   → Commit succeeds ✅                                   │
│                                                          │
│ IF: Approval + recommendations                          │
│   → Agent: Decides if recommendations are significant   │
│   → IF significant: implement → REPEAT cycle            │
│   → IF not significant: AUTO_ACCEPT=true → Commit ✅    │
│                                                          │
│ IF: Issues found (bugs, security, etc.)                │
│   → Agent: Fix issues → REPEAT cycle                    │
└─────────────────────────────────────────────────────────┘
```

### Commit Approval Decision Logic

When Claude provides review feedback, the agent must:

#### **Scenario 1: Approval with "No Issues" or "Ready to Commit"**
```
Claude says: "✅ APPROVED - Code looks good, no issues found"

Agent action:
→ IMMEDIATELY resubmit with AUTO_ACCEPT=true
→ Use EXACT same commit message
→ DO NOT make any changes
```

#### **Scenario 2: Approval with Non-Blocking Recommendations**
```
Claude says: "✅ APPROVED - Consider adding JSDoc comments for public methods"

Agent decision tree:
1. Are recommendations significant (improve quality/security/performance)?
   YES → Implement recommendations → Request NEW approval
   NO → Proceed with AUTO_ACCEPT=true

2. Are recommendations in scope for this task?
   YES → Consider implementing
   NO → Defer (can be separate task)

3. Is there clear reason to defer?
   YES → Proceed with AUTO_ACCEPT=true
   NO → Implement if significant
```

#### **Scenario 3: Issues Found (Bugs, Security, Critical)**
```
Claude says: "❌ ISSUES FOUND - SQL injection vulnerability in line 42"

Agent action:
→ Fix ALL critical issues
→ Request NEW approval (DO NOT use AUTO_ACCEPT)
→ REPEAT approval cycle
```

#### **Scenario 4: Pre-commit Hook Failure (Non-Review)**
```
Pre-commit hook fails with: "ESLint error: Unused variable 'foo'"

Agent action:
→ STOP autonomous execution
→ Report error to user
→ Wait for manual intervention
→ DO NOT attempt AUTO_ACCEPT
```

### AUTO_ACCEPT Usage Rules

#### **ALLOWED to use AUTO_ACCEPT=true when:**
✅ Claude explicitly approved the commit
✅ No changes made since approval
✅ Resubmitting EXACT same commit message
✅ Agent chose to defer non-blocking recommendations

#### **FORBIDDEN to use AUTO_ACCEPT=true when:**
❌ No approval received yet
❌ Any changes made after approval (even minor)
❌ Pre-commit hook failed for non-review reasons
❌ Attempting to bypass review process
❌ Using `-n` or `--no-verify` flags (NEVER allowed)

### Detecting Commit Approval

Claude's approval may come in various formats. Look for these signals:

**Approval Indicators:**
- "✅ APPROVED"
- "Looks good"
- "Ready to commit"
- "No issues found"
- "LGTM" (Looks Good To Me)
- "Proceed with commit"
- "All checks pass"

**NOT Approval:**
- "Consider..."
- "Suggest..."
- "Could improve..."
- "Minor issue..." (WITHOUT explicit approval)

**Issues Found (NOT Approval):**
- "❌" or "⚠️" symbols
- "Issue", "Bug", "Error", "Problem"
- "Security vulnerability"
- "Must fix", "Should fix", "Required"

### Example Approval Flow

**Iteration 1:**
```bash
$ git commit -m "feat: implement user authentication"
# Claude reviews, says: "Consider adding rate limiting"
# Agent decides: rate limiting is significant → implement it
```

**Iteration 2:**
```bash
$ git commit -m "feat: implement user authentication"
# Claude reviews, says: "✅ APPROVED - Looks good with rate limiting"
# Agent sees approval + no issues → use AUTO_ACCEPT
```

**Final Commit:**
```bash
$ AUTO_ACCEPT=true git commit -m "feat: implement user authentication"
# Bypasses interactive prompt → Commit succeeds ✅
```

---

## Context Window Management

### Monitoring Context Usage

The agent should track token usage throughout execution. When context reaches **90% capacity**:

1. **Pause current task** (finish current operation, don't start new tests/implementation)
2. **Update memory bank** with all recent work
3. **Compact context** using progressive reduction (see below)
4. **Resume current task** from where it paused

### Progressive Context Reduction

When compacting at 90% capacity, remove in this priority order:

#### **Priority 1: Remove Code Snippets**
- Remove large code blocks from earlier tasks
- Keep only file paths and brief descriptions
- Preserve error messages and critical details

#### **Priority 2: Remove Old Task Details**
- Summarize completed tasks (keep only: task ID, status, commit hash)
- Remove implementation details from tasks >2 tasks ago
- Keep current task details intact

#### **Priority 3: Remove Conditional Docs**
- Remove conditional context (if it was included):
  - Recent commit history (if >5 commits loaded)
  - systemPatterns.md (if no architectural changes in progress)
- Keep essential context:
  - activeContext.md (always keep)
  - Current task details (always keep)
  - Architecture.md relevant sections (always keep)

#### **Priority 4: Summarize Memory Bank Entries**
- Create inline summary of older memory bank entries
- Keep most recent "Recent Changes" in activeContext.md
- Remove older "Recent Changes" entries (>1 week old)

### Context Compaction Example

**Before (90% capacity):**
```
Memory Bank: Full activeContext.md, progress.md, systemPatterns.md
Task 1.1: Full implementation details, test code, review iterations
Task 1.2: Full implementation details, test code, review iterations
Task 1.3: [CURRENT] Full details
Architecture: 3 full sections loaded
Commit History: Last 10 commits with diffs
```

**After (reduced to ~60% capacity):**
```
Memory Bank: activeContext.md, progress.md summary
Task 1.1: ✅ Complete - Commit abc123 - DynamoDB client implemented
Task 1.2: ✅ Complete - Commit def456 - Retry logic implemented
Task 1.3: [CURRENT] Full details (preserved)
Architecture: Current relevant section only
Commit History: Removed
```

---

## Task Tracker Status Management

### Five-State System

Autonomous mode uses these task states:

- `[ ]` **Not Started** - Task not yet begun
- `[>]` **In Progress** - Task currently being worked on
- `[x]` **Completed** - Task finished successfully
- `[~]` **Skipped** - Task deferred or not needed
- `[!]` **Failed** - Task failed after 3 retry attempts

### State Transitions in Autonomous Mode

```
[ ] → [>] : Start task
[>] → [x] : Tests pass, commit successful
[>] → [!] : 3 retry attempts exhausted
[!] → [>] : User fixes issue, agent retries (manual restart)
[ ] → [~] : User requests skip, or task no longer needed
```

### Handling Failed Tasks `[!]`

When a task reaches `[!]` status:

1. **Document failure** in memory-bank/progress.md:
   - Error details
   - What was attempted
   - Why retries failed
   - Recommended fix

2. **Update task tracker**:
   - Mark task as `[!]`
   - Add failure note in completion log

3. **HALT execution**:
   - Stop autonomous mode
   - Report failure to user
   - List remaining tasks

4. **Recovery** (when user reruns `/one-shot` or `/batch`):
   - Agent can retry `[!]` tasks automatically
   - Starts fresh (not from saved state)
   - If fails again → mark `[!]` again and halt

---

## Phase Completion Procedures

When all tasks in a phase are complete:

### 1. Update Memory Bank
- Full update of memory-bank/activeContext.md
- Full update of memory-bank/progress.md
- Update memory-bank/systemPatterns.md if architecture changed
- Mark phase complete

### 2. Update Task Tracker
- Mark all phase tasks as `[x]`
- Update phase progress to 100%
- Update overall progress percentage
- Add completion log entry with date

### 3. Generate Phase Summary
- Create summary in `_context-summaries/[DATE]-phase-[N]-[name].md`
- Use format from example: `@_context-summaries/2025-11-11-phase1-services-implementation.md`
- Include:
  - Tasks completed
  - Files changed
  - Key decisions with rationale
  - Non-obvious solutions (if any)
  - Testing approach
  - Blockers resolved
  - Next steps

### 4. Report Completion
```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
PHASE [N] COMPLETED
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Tasks: [M]/[M] completed successfully
Commits: [M] commits created
Files: [X] files changed
Tests: All passing

Phase Summary: _context-summaries/[DATE]-phase-[N]-[name].md

Next Phase: Phase [N+1] - [Name]

Ready for user review.
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

---

## Error Handling in Autonomous Mode

### Retry Strategy

**Test Failures:**
- Attempt 1: Run tests, analyze failures
- Attempt 2: Fix issues, rerun tests
- Attempt 3: Fix remaining issues, rerun tests
- After 3 attempts: Mark as `[!]`, halt execution

**Pre-commit Hook Failures (Non-Review):**
- Do NOT retry automatically
- Report error to user
- HALT execution
- Wait for manual intervention

**Claude Review Iterations:**
- No retry limit (not a "failure")
- Continue until approval or critical issue
- Implement fixes as needed
- Request new approval after changes

### Halting Conditions

**MUST HALT autonomous execution when:**
- Task fails after 3 retry attempts
- Pre-commit hook failure (linting, type errors)
- Requirements are ambiguous/unclear
- Critical error that cannot be auto-resolved
- Phase completion (for review)

**DO NOT HALT for:**
- Successful task completion
- Claude review iterations
- Memory bank updates
- Minor warnings in tests/linting (if they pass)

---

## Inter-Task Validation

Before proceeding to next task in autonomous mode, verify:

- [ ] All tests passing (including previously passing tests)
- [ ] No uncommitted changes (commit successful)
- [ ] Memory bank updated (if needed)
- [ ] Task tracker updated
- [ ] Git working directory clean
- [ ] No blocking errors in logs

If ANY validation fails:
→ HALT execution
→ Report issue to user
→ Wait for resolution

---

## Communication in Autonomous Mode

### Progress Reporting

Show concise progress updates during execution:

```
Starting Task [N] of [M]: [task-id] - [task-name]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Progress: [N]/[M] tasks ([X]%)

[Brief status updates during implementation]

Task [N] COMPLETED ✅
Commit: [hash] - [message]
Files: [count] changed
Tests: [count] passing

Continuing to next task...
```

### DO NOT Output in Autonomous Mode:
- Detailed plans (plan silently)
- Full code implementations (unless error)
- Step-by-step reasoning (work silently)
- Approval requests between tasks
- Verbose status updates

### DO Output in Autonomous Mode:
- Task start/completion
- Progress indicators
- Error messages
- Critical decisions
- Final summary

---

## Rules Summary

### Autonomous Mode Principles

**1. Continuity**
- Execute tasks continuously without pausing between completions
- Only stop for errors, ambiguity, or phase completion

**2. Silent Planning**
- Create plans internally without showing to user
- Make implementation decisions autonomously
- Follow established patterns from architecture

**3. Smart Commit Approval**
- Handle Claude review iterations automatically
- Implement significant recommendations
- Use AUTO_ACCEPT=true only after approval with no changes
- Never bypass review with --no-verify

**4. Context Management**
- Monitor token usage continuously
- Compact at 90% capacity
- Preserve essential context

**5. Error Recovery**
- Retry tests up to 3 times
- Halt on non-recoverable errors
- Document failures clearly

### Forbidden Actions (NEVER in Autonomous or Manual Mode)

❌ Use `git commit -n` or `git commit --no-verify`
❌ Use `git add .` or `git add -A`
❌ Use `AUTO_ACCEPT=true` without prior approval
❌ Use `AUTO_ACCEPT=true` after making changes post-approval
❌ Skip tests to continue execution
❌ Commit failing code
❌ Ignore ambiguous requirements
❌ Continue after 3 failed retry attempts
❌ Modify files outside task scope

### Safety Guarantees

The autonomous mode maintains these guarantees:

✅ All code reviewed by Claude before commit
✅ All tests pass before commit
✅ No secrets or sensitive data committed
✅ Memory bank stays current
✅ Clear audit trail (task tracker, commits, summaries)
✅ Can resume after interruption
✅ User can intervene at any time

---

## Integration with Commands

### Commands that Activate Autonomous Mode

- `/one-shot Phase N` - Execute all remaining tasks in phase N
- `/batch [tasks]` - Execute specified tasks autonomously

### Commands that Use Manual Mode

- `/plan` - Plan single task, show to user
- `/implement` - Implement with approval
- `/commit-with-approval` - Manual commit approval
- Individual task commands

---

**Remember**: Autonomous mode is about velocity with safety. The agent moves quickly through tasks but never bypasses quality gates (tests, code review, validation). When in doubt, pause and ask.
